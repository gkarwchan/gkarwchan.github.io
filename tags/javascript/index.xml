<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>javascript on Ghassan&#39;s Page</title>
    <link>https://www.ghassan.page/tags/javascript/</link>
    <description>Recent content in javascript on Ghassan&#39;s Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Jun 2024 10:41:54 -0600</lastBuildDate>
    <atom:link href="https://www.ghassan.page/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Stream long running webapi with Asp.NET Core and Javascript</title>
      <link>https://www.ghassan.page/posts/2024_06_22_streamline_long_process_with_aspnet_core_and_javascript/</link>
      <pubDate>Sat, 22 Jun 2024 10:41:54 -0600</pubDate>
      <guid>https://www.ghassan.page/posts/2024_06_22_streamline_long_process_with_aspnet_core_and_javascript/</guid>
      <description>If you have a long running process that return array of data, or a data that you can send back as chunk of data, then you can stream the result.
Streaming from the serverIn Asp.NET core 6 and later, it is so easy to stream back the result using IAsyncEnumerable.
Let us jump into the code right away:
1 [HttpGet(&amp;#34;ProcessLongData&amp;#34;)] 2 [ResponseCache(NoStore = true, Location = ResponseCacheLocation.None)] 3 public async IAsyncEnumerable&amp;lt;string&amp;gt; ProcessLongData(string input) 4 { 5 6 7 for (var i = 0; i &amp;lt; 10; i++) 8 { 9 await Task.</description>
    </item>
    <item>
      <title>No More JavaScript Transpiler</title>
      <link>https://www.ghassan.page/posts/2020_12_23_no_more_js_transpiler/</link>
      <pubDate>Wed, 23 Dec 2020 16:02:54 -0700</pubDate>
      <guid>https://www.ghassan.page/posts/2020_12_23_no_more_js_transpiler/</guid>
      <description>&lt;p&gt;With modern browsers supporting ES6 modules, and Edge is adopting Chromium which align the major browsers to use latest EcmaScript features, we don&amp;rsquo;t need to use transpilers like Webpack or Gulp.&lt;br&gt;
This will make it easier on many areas, and enhance the performance of our applications.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Memoization in Python and JavaScript</title>
      <link>https://www.ghassan.page/posts/2020_09_20_memoization_python_javascript/</link>
      <pubDate>Sun, 20 Sep 2020 09:45:00 +0000</pubDate>
      <guid>https://www.ghassan.page/posts/2020_09_20_memoization_python_javascript/</guid>
      <description>&lt;p&gt;Memoization is a technique that is used a lot in Dynamic Programming and in general to speed up algorithms.&lt;br&gt;
Memoization is the same as caching but in functional programming. The Caching mechanism will store the data into a cache store, and that data can be from anywhere (HTTP page, REST call, &amp;hellip; etc) , where memoization is specific to cache the results of a function, and it create and maintain the store inside the function itself (so the function will be pure function) and send the store as a parameter into the function arguments.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ajax, CORS, JSONP and the battle with Same-Origin Policy</title>
      <link>https://www.ghassan.page/posts/2015_12_16_ajax_cors/</link>
      <pubDate>Wed, 16 Dec 2015 19:51:56 -0700</pubDate>
      <guid>https://www.ghassan.page/posts/2015_12_16_ajax_cors/</guid>
      <description>All modern browsers have a built-in security policy called Same-origin policy, which help mitigate many vulnerabilities and security flaws. This policy means the browser can only pull data from the same site.
Same site means pages that share the scheme (http, ftp, https&amp;hellip;), and the host name and the port.
The clash between Same-Origin Policy and AjaxThis policy was useful for a while to protect against XSS, but with the advance of ajax, and requesting data and resources from different domains and sites, then this policy become an obstacle.</description>
    </item>
    <item>
      <title>CSS Fonts</title>
      <link>https://www.ghassan.page/posts/2015_11_26_css_fonts/</link>
      <pubDate>Thu, 26 Nov 2015 19:51:56 -0700</pubDate>
      <guid>https://www.ghassan.page/posts/2015_11_26_css_fonts/</guid>
      <description>The simplist way to use different fonts in your web site is using fonts from the &amp;ldquo;Web-Safe&amp;rdquo; fonts[1] [2].
But, no impressive design will depend only on these web-safe fonts, and designers add their own preferable fonts to the web site they are building.
How to add your preferable fonts?Fonts comes as files that you have to upload to the site, and then reference them in the CSS file.
Usually font vendors provide fonts with different formats in order to be consumable by many different browsers.</description>
    </item>
    <item>
      <title>CSS Reset</title>
      <link>https://www.ghassan.page/posts/2015_11_18_css_reset/</link>
      <pubDate>Wed, 18 Nov 2015 19:51:56 -0700</pubDate>
      <guid>https://www.ghassan.page/posts/2015_11_18_css_reset/</guid>
      <description>Every web developer had an experience where he test his web site on Chrome, IE and FireFox, to find out that the experience is a little bit different, because browsers have their own default implementation and rendering for the HTML elements. Which means if you don&amp;rsquo;t overwrite the default implementation with your own CSS rules, then the browser will use its own implementation.
If you are very keen on making the exact same user experience between all browsers even with the smallest details, then the community came up with a technique called &amp;ldquo;CSS Reset&amp;rdquo;.</description>
    </item>
  </channel>
</rss>
